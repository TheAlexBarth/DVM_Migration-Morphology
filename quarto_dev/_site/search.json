[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Migrator Morphology",
    "section": "",
    "text": "Here, I investigate how diel vertical migration varies between copepods based on morphotypes determined from in-situ imaging."
  },
  {
    "objectID": "main_01_ctd_interp.html",
    "href": "main_01_ctd_interp.html",
    "title": "Physical Backdrop - water column parameters across study period",
    "section": "",
    "text": "Code\nrm(list = ls())\nlibrary(ggplot2)\nlibrary(ggpubr)\nfull_proj_values <- readRDS('../data/ctd_01_interp-grid.rds')$full_proj\n\nODV_colours <- c(\"#feb483\", \"#d31f2a\", \"#ffc000\", \"#27ab19\", \"#0db5e6\", \"#7139fe\", \"#d16cfa\")\n\n# set up\nvalue_class <- function(cruise){\n  ret_list <- vector('list',4)\n  names(ret_list) <- c('Sal',\"Temperature\",'RFU','DO')\n  return(ret_list)\n}\n\nfull_proj_plot <- list()\nfull_proj_plot$early <- value_class()\nfull_proj_plot$late <- value_class()\n\n\n# |- Plotting -----------------------\nfor(i in 1:length(full_proj_plot)) {\n  \n  full_proj_plot[[i]]$Sal <- ggplot()+\n    geom_tile(data = full_proj_values[[i]]$Sal,\n              aes(x = Date,\n                  y = Depth,\n                  fill = Sal)) +\n    scale_y_reverse()+\n    scale_fill_distiller(palette = 'Spectral')+\n    scale_color_manual(breaks = c('day','night'),\n                       values = c('grey','black'))+\n    scale_x_datetime(date_labels = '%Y-%b')+\n    labs(x = \"\",y = \"Depth [m]\", fill = \"Sal [PSU]\",\n         color = \"\")+\n    theme_pubr()+\n    theme(legend.position = 'right')+\n    coord_cartesian(expand = 0)\n  \n  full_proj_plot[[i]]$Temperature <- ggplot()+\n    geom_tile(data = full_proj_values[[i]]$Temperature,\n              aes(x = Date,\n                  y = Depth,\n                  fill = Temperature)) +\n    scale_y_reverse()+\n    scale_x_datetime(date_labels = '%Y-%b')+\n    scale_fill_gradientn(colors = rev(ODV_colours))+\n    scale_color_manual(breaks = c('day','night'),\n                       values = c('grey','black'))+\n    labs(x = \"\",y = \"Depth [m]\", fill = \"Temperature\",\n         color = \"\")+\n    theme_pubr()+\n    theme(legend.position = 'right')+\n    coord_cartesian(expand = 0)\n  \n  full_proj_plot[[i]]$RFU <- ggplot() + \n    geom_tile(data = full_proj_values[[i]]$RFU,\n              aes(x = Date,\n                  y = Depth,\n                  fill = RFU)) +\n    scale_y_reverse()+\n    scale_x_datetime(date_labels = '%Y-%b')+\n    scale_fill_distiller(palette = 'BuGn',\n                         direction = 1)+\n    scale_color_manual(breaks = c('day','night'),\n                       values = c('grey','black'))+\n    labs(x = \"\",y = \"Depth [m]\", fill = \"RFU\",\n         color = \"\")+\n    theme_pubr()+\n    theme(legend.position = 'right')+\n    coord_cartesian(expand = 0)\n  \n  full_proj_plot[[i]]$DO <- ggplot() + \n    geom_tile(data = full_proj_values[[i]]$DO,\n              aes(x = Date,\n                  y = Depth,\n                  fill = DO)) +\n    scale_y_reverse()+\n    scale_fill_distiller(palette = 'GnBu',\n                         direction = 1)+\n    scale_color_manual(breaks = c('day','night'),\n                       values = c('grey','black'))+\n    labs(x = \"\",y = \"Depth [m]\", fill = \"DO\",\n         color = \"\")+\n    theme_pubr()+\n    theme(legend.position = 'right')+\n    coord_cartesian(expand = 0)\n  \n}\n\n\n\n\nCode\nggarrange(full_proj_plot$early$Sal +\n            theme(axis.text.x = element_text(angle = 45,\n                                             hjust = 1,\n                                             vjust = 1)),\n          full_proj_plot$late$Sal +\n            theme(axis.text.y = element_blank(),\n                  axis.text.x = element_text(angle = 45,\n                                             hjust = 1,\n                                             vjust = 1))+\n            labs(y = \"\"),\n          common.legend = T,\n          legend = 'right',\n          nrow = 1,\n          widths = c(0.2,0.8),\n          align = 'hv')\n\n\n\n\n\nFigure 1a. Salinity values across whole study period interpolated from ctd casts.\n\n\n\n\n\n\nCode\nggarrange(full_proj_plot$early$Temperature +\n            theme(axis.text.x = element_text(angle = 45,\n                                             hjust = 1,\n                                             vjust = 1)),\n          full_proj_plot$late$Temperature +\n            theme(axis.text.y = element_blank(),\n                  axis.text.x = element_text(angle = 45,\n                                             hjust = 1,\n                                             vjust = 1))+\n            labs(y = \"\"),\n          common.legend = T,\n          legend = 'right',\n          nrow = 1,\n          widths = c(0.2,0.8),\n          align = 'hv')\n\n\n\n\n\nFigure 1b. Temperature values across whole study period interpolated from ctd casts.\n\n\n\n\n\n\nCode\nggarrange(full_proj_plot$early$RFU +\n            theme(axis.text.x = element_text(angle = 45,\n                                             hjust = 1,\n                                             vjust = 1)),\n          full_proj_plot$late$RFU +\n            theme(axis.text.y = element_blank(),\n                  axis.text.x = element_text(angle = 45,\n                                             hjust = 1,\n                                             vjust = 1))+\n            labs(y = \"\"),\n          common.legend = T,\n          legend = 'right',\n          nrow = 1,\n          widths = c(0.2,0.8),\n          align = 'hv')\n\n\n\n\n\nFigure 1c. RFU values across whole study period interpolated from ctd casts.\n\n\n\n\n\n\nCode\nggarrange(full_proj_plot$early$DO +\n            theme(axis.text.x = element_text(angle = 45,\n                                             hjust = 1,\n                                             vjust = 1)),\n          full_proj_plot$late$DO +\n            theme(axis.text.y = element_blank(),\n                  axis.text.x = element_text(angle = 45,\n                                             hjust = 1,\n                                             vjust = 1))+\n            labs(y = \"\"),\n          common.legend = T,\n          legend = 'right',\n          nrow = 1,\n          widths = c(0.2,0.8),\n          align = 'hv')\n\n\n\n\n\nFigure 1d. DO values across whole study period interpolated from ctd casts."
  },
  {
    "objectID": "main_02_PC-Clusters.html",
    "href": "main_02_PC-Clusters.html",
    "title": "Morphogroup Definition",
    "section": "",
    "text": "Code\nrm(list = ls())\nlibrary(DT)\nlibrary(EcotaxaTools)\nlibrary(ggplot2)\nlibrary(ggpubr)\nsource('../R/tools.R')\n\npca_results <- readRDS('../data/02_cope-pca-res.rds')\ncluster_res <- readRDS('../data/02_cluster-copepods.rds')\nA PCA was run on the morphological features for each vignette. Principle components with eigenvalues greater than 1 were considered. This comprised the first four PCs, which explained a total of 87.9% of the variance in the data (view the complete PCA results check supplemental information 2. The first two components explained 34.23% and 27.24% respectively. The first principle component was largely correlated with metrics associated with size (perimeter, feret diameter, fractal dimension, major axis). The second principle component is best described by darkness, where positive values indicate more transparent organisms and negative values are darker ones. Similar to Vilgraine et al.Â (2020), we observe the third PC to be best described by orientation and the fourth axis to be described by appendage visibility. It can be assumed that the orientation and appendage visibility of copepods are artefacts of the imaging method and not indicative of their ecology/behavior. For this reason, we chose to only include the first two axis for definition of morphogroups. A k-means cluster analysis was used to identify morphogroups within the first two PC-space. Four clusters were determined to be the optimal number of groups as it captured 65% of the variability in the morphospace and additional clusters added less than 10% explanatory power. Individual observations were assigned to morphogroups based on the k-means analysis, which was conducted using 1000 random starts. The analysis converged on consistent results across iterations."
  },
  {
    "objectID": "main_03_PC-model.html",
    "href": "main_03_PC-model.html",
    "title": "PC- Depth predictive model",
    "section": "",
    "text": "Code\n# ggplot(trim_cope) +\n#   geom_point(aes(x = ))"
  },
  {
    "objectID": "main_03_Vert-Distrib.html",
    "href": "main_03_Vert-Distrib.html",
    "title": "Vertical Distribution of Morphotypes",
    "section": "",
    "text": "Code\n#| column: page-inset\n\nggarrange(cluster_1_profile,\n          cluster_2_profile + \n            theme(axis.text.y = element_blank(),\n                  axis.title.y = element_blank()),\n          cluster_3_profile + \n            theme(axis.text.y = element_blank(),\n                  axis.title.y = element_blank()),\n          cluster_4_profile + \n            theme(axis.text.y = element_blank(),\n                  axis.title.y = element_blank()),\n          diff_1_profile,\n          diff_2_profile + \n            theme(axis.text.y = element_blank(),\n                  axis.title.y = element_blank()),\n          diff_3_profile + \n            theme(axis.text.y = element_blank(),\n                  axis.title.y = element_blank()),\n          diff_4_profile + \n            theme(axis.text.y = element_blank(),\n                  axis.title.y = element_blank()),\n          nrow = 2, ncol = 4,\n          widths = c(1,.9,.9,.9))\n\n\n\n\n\nWe can zoom in on the upper 600m to get a better picture of the changes in the upper layers.\n\n\nCode\n#| column: screen-inset\n\nggarrange(cluster_1_profile +\n            xlim(600,0),\n          cluster_2_profile + \n            theme(axis.text.y = element_blank(),\n                  axis.title.y = element_blank()) +\n            xlim(600,0),\n          cluster_3_profile + \n            theme(axis.text.y = element_blank(),\n                  axis.title.y = element_blank()) +\n            xlim(600,0),\n          cluster_4_profile + \n            theme(axis.text.y = element_blank(),\n                  axis.title.y = element_blank()) +\n            xlim(600,0),\n          diff_1_profile +\n            xlim(600,0),\n          diff_2_profile + \n            theme(axis.text.y = element_blank(),\n                  axis.title.y = element_blank()) +\n            xlim(600,0),\n          diff_3_profile + \n            theme(axis.text.y = element_blank(),\n                  axis.title.y = element_blank()) +\n            xlim(600,0),\n          diff_4_profile + \n            theme(axis.text.y = element_blank(),\n                  axis.title.y = element_blank()) +\n            xlim(600,0),\n          nrow = 2, ncol = 4,\n          widths = c(1,.9,.9,.9))\n\n\n\n\n\nNext, to better understand the magnitude of DVM within morphotype groups, weighted mean depths were calucated using a bin-constrained bootstrap approach (bc_boot). By using the bcBoot method, confidence intervals can be constructed around the estimates of WMD. The size of the confidence interval represents both the spread of the MG throughout the water column and the accuracy of the estimate, given the available data. i.e.Â a wider confidence interval indicates that the distribution of the MG throughout the water column is larger or the data available are more sparse. If the nighttime and daytime WMD confidence intervals do not overlap, we can conclude that the morphogroup has a clear signal of DVM.\n\n\nCode\nboot_wmd <- readRDS('../data/04_wmd-all-merged.rds')\n\nday_summary <- boot_wmd$day |> lapply(quantile, probs = c(0.025,0.5,0.975))\nnight_summary <- boot_wmd$night |> lapply(quantile, probs = c(0.025,0.5,0.975))\n\nwmd_df <- data.frame(cluster = rep(1:4, 2),\n                     tod = rep(c('day','night'),each = 4),\n                     low = rep(NA, 8),\n                     mid = rep(NA, 8),\n                     high = rep(NA, 8))\n\nfor(i in 1:4) {\n  \n  wmd_df$low[which(wmd_df$tod == 'day' & \n                     wmd_df$cluster == i)] <- day_summary[[i]][['2.5%']]\n  wmd_df$mid[which(wmd_df$tod == 'day' & \n                     wmd_df$cluster == i)] <- day_summary[[i]][['50%']]\n  wmd_df$high[which(wmd_df$tod == 'day' & \n                     wmd_df$cluster == i)] <- day_summary[[i]][['97.5%']]\n  \n  \n  wmd_df$low[which(wmd_df$tod == 'night' & \n                     wmd_df$cluster == i)] <- night_summary[[i]][['2.5%']]\n  wmd_df$mid[which(wmd_df$tod == 'night' & \n                     wmd_df$cluster == i)] <- night_summary[[i]][['50%']]\n  wmd_df$high[which(wmd_df$tod == 'night' & \n                     wmd_df$cluster == i)] <- night_summary[[i]][['97.5%']]\n  \n}\n\n\nggplot(wmd_df) +\n  geom_point(aes(x = cluster,\n                 y = mid,\n                 color = tod),\n             position = position_dodge(width = .5),\n             size = 2) +\n  geom_errorbar(aes(x = cluster,\n                    ymin = low,\n                    ymax = high,\n                    color = tod),\n                width = .25,\n                position = position_dodge(width = .5),\n                size = 1) +\n  scale_color_manual(values = c(dn_cols['day'],dn_cols['night'])) +\n  scale_y_reverse(limits = c(600,0)) +\n  labs(y = 'Depth [m]', x = 'Morphogroup Cluster', col = \"\")+\n  theme_pubr()"
  },
  {
    "objectID": "main_04_DVM-amplitude-seasonal.html",
    "href": "main_04_DVM-amplitude-seasonal.html",
    "title": "Weighted Mean Depth Across cruises",
    "section": "",
    "text": "Code\n#| column: screen-inset\n\nrm(list = ls())\nlibrary(EcotaxaTools)\nlibrary(ggplot2)\nlibrary(ggpubr)\nlibrary(lubridate)\nsource('../R/tools.R')\n\n# |- load in data ---------------------------------------------\nwmd_data <- readRDS('../data/04_wmd-by-cruise-seasonal.rds')\n\n\n# |- format wmd CIs for each cruise --------------------------\n\n# honestly, at this point I've created a ridiculous data structure\n# the list is too deep - it is a messy tree\n# there has to be a better way but this is going to just be an ugly solution\n# I have re-sampled distributions in a tree-like list. I then need to get the quantiles\n# and force it all into a top-level dataframe\n\nwmd_list <- vector('list',length(wmd_data))\nnames(wmd_list) <- names(wmd_data)\nfor(i in 1:length(wmd_list)) {\n  #get quantiles recursively\n  wmd_list[[i]] <- wmd_data[[i]] |> \n    lapply(function(x) lapply(x, quantile, probs = c(0.025,.5,0.975), na.rm = T)) \n  \n  \n  wmd_list[[i]] <- wmd_list[[i]] |> \n    lapply(function(x) lapply(x, quant_to_df)) |> \n    lapply(list_to_tib, 'metric') |> \n    list_to_tib('cluster')\n}\nwmd_df <- wmd_list |> list_to_tib('season')\n\nwmd_df$season <- factor(wmd_df$season,\n                        levels = c('winter',\n                                   'spring',\n                                   'summer',\n                                   'fall'))\n\n###\n# Plotting ################\n###\n\n\ndvm_amplitude <- ggplot(wmd_df[wmd_df$metric == 'dn_diff',]) +\n  geom_point(aes(x = season,\n                 y = mid,\n                 color = cluster,\n                 shape = cluster),\n             size = 2.5,\n             position = position_dodge(.5)) +\n  geom_errorbar(aes(x = season,\n                    ymin = low,\n                    ymax = high,\n                    color = cluster),\n                size = .5,\n                width = .25,\n                position = position_dodge(.5)) + \n  geom_hline(yintercept = 0, color = 'lightgrey', size = .5) +\n  scale_color_manual(values = gg_cbb_col(4)) +\n  labs(x = '', y = 'Depth [m]', color = \"\", shape = \"\") +\n  theme_pubr()\n\nmed_day_depth <- ggplot(wmd_df[wmd_df$metric == 'wmd_d',]) +\n  geom_point(aes(x = season,\n                 y = mid,\n                 color = cluster,\n                 shape = cluster),\n             size = 2.5,\n             position = position_dodge(.5)) +\n  geom_errorbar(aes(x = season,\n                    ymin = low,\n                    ymax = high,\n                    color = cluster),\n                size = .5,\n                width = .25,\n                position = position_dodge(.5)) + \n  geom_hline(yintercept = 0, color = 'lightgrey', size = .5) +\n  scale_color_manual(values = gg_cbb_col(4)) +\n  scale_y_reverse(expand =c(0,0)) + \n  scale_x_discrete(position = 'top') + \n  labs(x = '', y = 'Depth [m]', color = \"\", shape = \"\") +\n  theme_pubr()\n\n\nggarrange(dvm_amplitude + \n            theme(axis.text.x = element_blank(),\n                  axis.title.x = element_blank()),\n          med_day_depth,\n          nrow =2,\n          common.legend = T)"
  },
  {
    "objectID": "main_04_DVM-amplitude.html",
    "href": "main_04_DVM-amplitude.html",
    "title": "DVM Seasonality",
    "section": "",
    "text": "Code\n#| column: body-outset\n\nrm(list = ls())\nlibrary(EcotaxaTools)\nlibrary(ggplot2)\nlibrary(ggpubr)\nlibrary(lubridate)\nsource('../R/tools.R')\n\n# |- load in data ---------------------------------------------\nwmd_data <- readRDS('../data/04_wmd-by-cruise.rds')\nuvp_data_meta <- readRDS('../data/01_uvp-trim-final.rds')$meta\nuvp_data_meta$cruise_id <- paste0(uvp_data_meta$stationid,\n                                  uvp_data_meta$programid)\n\nuvp_data_meta$dateabv <- paste(year(uvp_data_meta$sampledate),\n                               month(uvp_data_meta$sampledate),\n                               '01', sep = '-') |> \n  as.Date()\n\n\n# |- format wmd CIs for each cruise --------------------------\n\n# honestly, at this point I've created a ridiculous data structure\n# the list is too deep - it is a messy tree\n# there has to be a better way but this is going to just be an ugly solution\n# I have re-sampled distributions in a tree-like list. I then need to get the quantiles\n# and force it all into a top-level dataframe\n\nwmd_list <- vector('list',length(wmd_data))\nnames(wmd_list) <- names(wmd_data)\nfor(i in 1:length(wmd_list)) {\n  #get quantiles recursively\n  wmd_list[[i]] <- wmd_data[[i]] |> \n    lapply(function(x) lapply(x, quantile, probs = c(0.025,.5,0.975), na.rm = T)) \n  \n  \n  wmd_list[[i]] <- wmd_list[[i]] |> \n    lapply(function(x) lapply(x, quant_to_df)) |> \n    lapply(list_to_tib, 'metric') |> \n    list_to_tib('cluster')\n}\nwmd_df <- wmd_list |> list_to_tib('cruise_id')\n\nwmd_df$date <- rep(NA, nrow(wmd_df))\nfor(i in 1:length(unique(wmd_df$cruise_id))) {\n  cruise_temp <- unique(wmd_df$cruise_id)[i]\n  meta_idx <- which(uvp_data_meta$cruise_id == unique(wmd_df$cruise_id)[i])\n  wmd_idx <- which(wmd_df$cruise_id == unique(wmd_df$cruise_id)[i])\n  wmd_df$date[wmd_idx] <- unique(uvp_data_meta$dateabv[meta_idx])\n}\nwmd_df$date <- wmd_df$date |> as.Date(origin = '1970-01-01')\n\n\nmonth_df <- aggregate(list(low = wmd_df$low, \n                           mid = wmd_df$mid, \n                           high = wmd_df$high),\n                      by = list(metric = wmd_df$metric,\n                                cluster = wmd_df$cluster,\n                                month = month(wmd_df$date)),\n                      FUN = mean, na.rm = T)\n\ndvm_amplitude <- ggplot(month_df[month_df$metric == 'dn_diff',]) +\n  geom_point(aes(x = month,\n                 y = mid,\n                 color = cluster,\n                 shape = cluster),\n             size = 2.5,\n             position = position_dodge(.5)) +\n  geom_errorbar(aes(x = month,\n                 ymin = low,\n                 ymax = high,\n                 color = cluster),\n             size = .5,\n             width = .25,\n             position = position_dodge(.5)) + \n  geom_hline(yintercept = 0, color = 'lightgrey', size = .5) +\n  scale_color_manual(values = gg_cbb_col(4)) +\n  labs(x = 'Month', y = 'Depth [m]', color = \"\") +\n  scale_x_continuous(breaks = seq(1:12)) +\n  theme_pubr()\n\nmed_day_depth <- ggplot(month_df[month_df$metric == 'wmd_d',]) +\n  geom_point(aes(x = month,\n                 y = mid,\n                 color = cluster,\n                 shape = cluster),\n             size = 2.5,\n             position = position_dodge(.5)) +\n  geom_errorbar(aes(x = month,\n                 ymin = low,\n                 ymax = high,\n                 color = cluster),\n             size = .5,\n             width = .25,\n             position = position_dodge(.5)) + \n  scale_color_manual(values = gg_cbb_col(4)) +\n  scale_x_continuous(breaks = seq(1:12),\n                     position = 'top') +\n  scale_y_reverse() +\n  labs(x = 'Month', y = 'Depth [m]', color = \"\") +\n  theme_pubr()\n\n\nggarrange(dvm_amplitude + \n            theme(axis.text.x = element_blank(),\n                  axis.title.x = element_blank()),\n          med_day_depth,\n          nrow =2,\n          common.legend = T)"
  },
  {
    "objectID": "main_05_model-seasonal.html",
    "href": "main_05_model-seasonal.html",
    "title": "DVM and Daytime depth model",
    "section": "",
    "text": "Code\n  # rm(list = ls())\n  # library(EcotaxaTools)\n  # library(ggplot2)\n  # library(ggpubr)\n  # library(lubridate)\n  # library(mgcv)\n  # source('../R/tools.R')\n  # \n  # # |- load in data ---------------------------------------------\n  # wmd_data <- readRDS('../data/04_wmd-by-cruise-seasonal.rds')\n  # # |- format wmd CIs for each cruise --------------------------\n  # wmd_df <- wmd_df_construct(wmd_data,'season')\n  # \n  # sat_data <- readRDS('../data/05_modis-month-sum.rds')\n  # \n  # sat_data$season <- sapply(sat_data$Date, season_assign)\n  # sat_data <- sat_data |> \n  #   group_by(season) |> \n  #   summarize(par = mean(par,na.rm =T),\n  #             dwi = mean(dwi, na.rm = T))\n  # \n  # part_data <- readRDS('../data/05_cast-metrics.rds')\n  # \n  # for(i in 1:10000) {\n  #   print(\"INCOMPLETE\")\n  # }\n  # \n  # stop('dubmmy')\n  # \n  # part_data <- part_data[order(part_data$profileid, uvp_data_meta$profileid),]\n  # part_data$cruise_id <- uvp_data_meta$cruise_id\n  # part_data_cruise <- part_data |> \n  #   group_by(cruise_id) |> \n  #   summarise(dcm_d = mean(dcm_d,na.rm = T),\n  #             intg_part = mean(intg_part, na.rm = T))\n  # \n  # # |- format wmd CIs for each cruise --------------------------\n  # wmd_df <- wmd_df_construct(wmd_data,'cruise')\n  # wmd_df$date <- wmd_df$date |> as.Date(origin = '1970-01-01')\n  # \n  # # |- pull all together ----------------------------\n  # full_data <- wmd_df\n  # full_data$par <- rep(NA,nrow(full_data))\n  # full_data$dwi <- rep(NA, nrow(full_data))\n  # full_data$dcm_d <- rep(NA,nrow(full_data))\n  # full_data$part250 <- rep(NA,nrow(full_data))\n  # \n  # for(i in 1:length(unique(full_data$cruise_id))) {\n  #   cruise <-  unique(full_data$cruise_id)[i]\n  #   full_idx <- which(full_data$cruise_id == cruise)\n  #   part_idx <- which(part_data_cruise$cruise_id == cruise)\n  #   date <- full_data$date[full_idx] |> unique()\n  #   sat_idx <- which(sat_data$Date == date)\n  #   \n  #   full_data$par[full_idx] <- sat_data$par[sat_idx]\n  #   full_data$dwi[full_idx] <- sat_data$dwi[sat_idx]\n  #   full_data$dcm_d[full_idx] <- part_data_cruise$dcm_d[part_idx]\n  #   full_data$part250[full_idx] <- part_data_cruise$intg_part[part_idx]\n  #}"
  },
  {
    "objectID": "main_05_model.html",
    "href": "main_05_model.html",
    "title": "DVM and Daytime depth model",
    "section": "",
    "text": "Now, models will be constructed to see if there is a clear relationship between environmental variables and DVM distance\n\n\nCode\ndvm <- full_data[full_data$metric == 'dn_diff',]\n\n# mod_list <- vector('list',length(unique(dvm$cluster)))\n# \n# for(i in 1:length(mod_list)) {\n#   temp_df <- dvm[dvm$cluster == unique(dvm$cluster)[i],]\n#   mod_list[[i]] <- lm(mid ~ (par) + (dwi) + (dcm_d) + (part250),\n#                       data = temp_df)\n# }\n\n# plotting all the variables\npar_plot <- ggplot(dvm) +\n  geom_point(aes(x = par,\n                 y = mid,\n                 color = cluster,\n                 shape = cluster),\n             size = 2) +\n  scale_color_manual(values = gg_cbb_col(4)) +\n  labs(x = 'PAR', y = 'DVM Amplitude') +\n  theme_pubr()\n\n\ndwi_plot <- ggplot(dvm) +\n  geom_point(aes(x = dwi,\n                 y = mid,\n                 color = cluster,\n                 shape = cluster),\n             size = 2) +\n  scale_color_manual(values = gg_cbb_col(4)) +\n  labs(x = '1/k490', y = 'DVM Amplitude') +\n  theme_pubr()\n\ndcm_d_plot <- ggplot(dvm) +\n  geom_point(aes(x = dcm_d,\n                 y = mid,\n                 color = cluster,\n                 shape = cluster),\n             size = 2) +\n  scale_color_manual(values = gg_cbb_col(4)) +\n  labs(x = 'DCM Depth [m]', y = 'DVM Amplitude') +\n  theme_pubr()\n\npart_plot <- ggplot(dvm) +\n  geom_point(aes(x = part250,\n                 y = mid,\n                 color = cluster,\n                 shape = cluster),\n             size = 2) +\n  scale_color_manual(values = gg_cbb_col(4)) +\n  labs(x = 'Integrated Euphotic Particle', y = 'DVM Amplitude') +\n  theme_pubr()\n\n\nggarrange(par_plot, dwi_plot,\n          dcm_d_plot, part_plot,\n          common.legend = T,\n          nrow = 2, ncol = 2)\n\n\n\n\n\n\n\nCode\nday_df <- full_data[full_data$metric == 'wmd_d',]\n\n# mod_list <- vector('list',length(unique(day_df$cluster)))\n# \n# for(i in 1:length(mod_list)) {\n#   temp_df <- day_df[day_df$cluster == unique(day_df$cluster)[i],]\n#   mod_list[[i]] <- lm(mid ~ s(par) + s(dwi) + s(dcm_d) + s(part250),\n#                       data = temp_df)\n# }\n\n# plotting all the variables\npar_plot <- ggplot(day_df) +\n  geom_point(aes(x = par,\n                 y = mid,\n                 color = cluster,\n                 shape = cluster),\n             size = 2) +\n  scale_color_manual(values = gg_cbb_col(4)) +\n  labs(x = 'PAR', y = 'Daytime WMD') +\n  theme_pubr()\n\n\ndwi_plot <- ggplot(day_df) +\n  geom_point(aes(x = dwi,\n                 y = mid,\n                 color = cluster,\n                 shape = cluster),\n             size = 2) +\n  scale_color_manual(values = gg_cbb_col(4)) +\n  labs(x = '1/k490', y = 'Daytime WMD') +\n  theme_pubr()\n\ndcm_d_plot <- ggplot(day_df) +\n  geom_point(aes(x = dcm_d,\n                 y = mid,\n                 color = cluster,\n                 shape = cluster),\n             size = 2) +\n  scale_color_manual(values = gg_cbb_col(4)) +\n  labs(x = 'DCM Depth [m]', y = 'Daytime WMD') +\n  theme_pubr()\n\npart_plot <- ggplot(day_df) +\n  geom_point(aes(x = part250,\n                 y = mid,\n                 color = cluster,\n                 shape = cluster),\n             size = 2) +\n  scale_color_manual(values = gg_cbb_col(4)) +\n  labs(x = 'Integrated Euphotic Particle', y = 'Daytime WMD') +\n  theme_pubr()\n\n\nggarrange(par_plot, dwi_plot,\n          dcm_d_plot, part_plot,\n          common.legend = T,\n          nrow = 2, ncol = 2)"
  },
  {
    "objectID": "supp_01_ctd-by-cruise.html",
    "href": "supp_01_ctd-by-cruise.html",
    "title": "CTD-interpolation across cruises",
    "section": "",
    "text": "Code\nfor(i in 1:length(plot_list)) {\n  \n  outplot <- ggarrange(plot_list[[i]]$Sal + \n                         guides(color = 'none')+\n                         theme(axis.text.x = element_blank()),\n                        plot_list[[i]]$Temperature+ \n                         guides(color = 'none')+\n                         theme(axis.text = element_blank())+\n                         labs(y = \"\"),\n                        plot_list[[i]]$RFU + \n                         guides(color = 'none'),\n                        plot_list[[i]]$DO +\n                         guides(color = 'none') +\n                         theme(axis.text.y = element_blank())+\n                         labs(y = \"\"),\n                        ncol = 2, nrow = 2,\n                       align = 'hv')\n              \n  annotate_figure(outplot, top = text_grob(paste0('Cruise: ',cruises[i]))) |> print()\n}\n\n\n\n\n\nPhysical parameters across individual cruises. Vertical bars indicate CTD casts events with black indicating night and grey indicating day.\n\n\n\n\n\n\n\nPhysical parameters across individual cruises. Vertical bars indicate CTD casts events with black indicating night and grey indicating day.\n\n\n\n\n\n\n\nPhysical parameters across individual cruises. Vertical bars indicate CTD casts events with black indicating night and grey indicating day.\n\n\n\n\n\n\n\nPhysical parameters across individual cruises. Vertical bars indicate CTD casts events with black indicating night and grey indicating day.\n\n\n\n\n\n\n\nPhysical parameters across individual cruises. Vertical bars indicate CTD casts events with black indicating night and grey indicating day.\n\n\n\n\n\n\n\nPhysical parameters across individual cruises. Vertical bars indicate CTD casts events with black indicating night and grey indicating day.\n\n\n\n\n\n\n\nPhysical parameters across individual cruises. Vertical bars indicate CTD casts events with black indicating night and grey indicating day.\n\n\n\n\n\n\n\nPhysical parameters across individual cruises. Vertical bars indicate CTD casts events with black indicating night and grey indicating day.\n\n\n\n\n\n\n\nPhysical parameters across individual cruises. Vertical bars indicate CTD casts events with black indicating night and grey indicating day.\n\n\n\n\n\n\n\nPhysical parameters across individual cruises. Vertical bars indicate CTD casts events with black indicating night and grey indicating day.\n\n\n\n\n\n\n\nPhysical parameters across individual cruises. Vertical bars indicate CTD casts events with black indicating night and grey indicating day.\n\n\n\n\n\n\n\nPhysical parameters across individual cruises. Vertical bars indicate CTD casts events with black indicating night and grey indicating day.\n\n\n\n\n\n\n\nPhysical parameters across individual cruises. Vertical bars indicate CTD casts events with black indicating night and grey indicating day.\n\n\n\n\n\n\n\nPhysical parameters across individual cruises. Vertical bars indicate CTD casts events with black indicating night and grey indicating day.\n\n\n\n\n\n\n\nPhysical parameters across individual cruises. Vertical bars indicate CTD casts events with black indicating night and grey indicating day.\n\n\n\n\n\n\n\nPhysical parameters across individual cruises. Vertical bars indicate CTD casts events with black indicating night and grey indicating day.\n\n\n\n\n\n\n\nPhysical parameters across individual cruises. Vertical bars indicate CTD casts events with black indicating night and grey indicating day."
  },
  {
    "objectID": "supp_02_pc-extended-info.html",
    "href": "supp_02_pc-extended-info.html",
    "title": "Additional PCA Information",
    "section": "",
    "text": "Additional Information related to the PCA used in this analysis are visible here. View the main conclusions from the analysis here.\nSpecific loading scores are available for each of the four dimensions:"
  },
  {
    "objectID": "supp_03_cluster-conc.html",
    "href": "supp_03_cluster-conc.html",
    "title": "Cruise Cluster Concentration",
    "section": "",
    "text": "Code\nrm(list = ls())\nlibrary(EcotaxaTools)\nlibrary(ggplot2)\nlibrary(ggpubr)\nlibrary(lubridate)\nsource('../R/tools.R')\n\nconc_data <- readRDS('../data/03_cluster-conc.rds') |> \n  lapply(bin_format) |> \n  lapply(function(x) x[which(x$max_d <= 600),1:3]) # this is really ugly bug fix 1:3, need to fix in package\n  \nuvp_data_meta <- readRDS('../data/01_uvp-trim-final.rds')$meta\nuvp_data_meta$cruise_id <- paste0(uvp_data_meta$stationid,\n                                  uvp_data_meta$programid)\n\nuvp_data_meta$dateabv <- paste(year(uvp_data_meta$sampledate),\n                               month(uvp_data_meta$sampledate),\n                               '01', sep = '-') |> \n  as.Date()\n\ncruise_casts <- vector('list', length(unique(uvp_data_meta$dateabv)))\nnames(cruise_casts) <- unique(uvp_data_meta$dateabv)\nfor(i in 1:length(cruise_casts)) {\n  cruise_casts[[i]] <- uvp_data_meta$profileid[which(uvp_data_meta$dateabv == names(cruise_casts)[i])]\n}\n\navg_conc <- conc_data |> \n  average_casts(cruise_casts) |> \n  lapply(integrate_all, need_format = T, subdivisions = 1000) |> \n  lapply(intg_to_tib) |> \n  list_to_tib('date')\n\n\navg_conc$date <- avg_conc$date |> as.Date()\n\nintg_plot_early <- ggplot(avg_conc[year(avg_conc$date) < 2020,]) +\n  geom_bar(aes(x = date,\n               y = intg,\n               fill = taxa),\n           stat = 'identity',\n           position = 'dodge') +\n  scale_fill_manual(values = gg_cbb_col(4)) +\n  scale_x_date(date_labels = '%Y-%m',\n               date_breaks = '1 month') +\n  scale_y_continuous(limits = c(0,350), expand = c(0,0)) +\n  labs(x = \"\", y = 'Integrated Abundance', fill = \"\") + \n  theme_pubr() +\n  theme(axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1))\n\nintg_plot <- ggplot(avg_conc[year(avg_conc$date) >= 2020,]) +\n  geom_bar(aes(x = date,\n               y = intg,\n               fill = taxa),\n           stat = 'identity',\n           position = 'dodge') +\n  scale_fill_manual(values = gg_cbb_col(4)) +\n  scale_x_date(date_labels = '%Y-%m',\n               date_breaks = '1 month') +\n  scale_y_continuous(limits = c(0,350), expand = c(0,0)) +\n  labs(x = \"\", y = 'Integrated Abundance', fill = \"\") + \n  theme_pubr() +\n  theme(axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1))\n\nggarrange(intg_plot_early,\n          intg_plot + theme(axis.title.y = element_blank(),\n                            axis.text.y = element_blank(),\n                            axis.line.y = element_blank(),\n                            axis.ticks.y = element_blank()),\n          common.legend = TRUE,\n          widths = c(0.2,0.80),\n          nrow = 1)"
  },
  {
    "objectID": "supp_04_wmd-by-cruise.html",
    "href": "supp_04_wmd-by-cruise.html",
    "title": "Weighted Mean Depth Across cruises",
    "section": "",
    "text": "Code\n#| column: screen-inset\n\nrm(list = ls())\nlibrary(EcotaxaTools)\nlibrary(ggplot2)\nlibrary(ggpubr)\nlibrary(lubridate)\nsource('../R/tools.R')\n\n# |- load in data ---------------------------------------------\nwmd_data <- readRDS('../data/04_wmd-by-cruise.rds')\nuvp_data_meta <- readRDS('../data/01_uvp-trim-final.rds')$meta\nuvp_data_meta$cruise_id <- paste0(uvp_data_meta$stationid,\n                                  uvp_data_meta$programid)\n\nuvp_data_meta$dateabv <- paste(year(uvp_data_meta$sampledate),\n                               month(uvp_data_meta$sampledate),\n                               '01', sep = '-') |> \n  as.Date()\n\n\n# |- format wmd CIs for each cruise --------------------------\nwmd_df <- wmd_df_construct(wmd_data,'cruise')\n\nwmd_df$date <- wmd_df$date |> as.Date(origin = '1970-01-01')\nwmd_df <- wmd_df[-which(wmd_df$metric == 'dn_diff'),]\n\n###\n# Plotting ################\n###\n\n# setting up a plotting shell\nplot_list <- list(\n  c1 = list(early = NULL,\n            full = NULL),\n  c2 = list(early = NULL,\n            full = NULL),\n  c3 = list(early = NULL,\n            full = NULL),\n  c4 = list(early = NULL,\n            full = NULL)\n)\n\nfor(i in 1:length(plot_list)) {\n  clust <- names(plot_list)[i]\n  plot_list[[i]]$early <- ggplot(wmd_df[year(wmd_df$date) < 2020 &\n                                          wmd_df$cluster == clust,]) +\n    geom_point(aes(x = date,\n                   y = mid,\n                   color = metric),\n               position = position_dodge(width = 5)) +\n    geom_errorbar(aes(x = date,\n                      ymin = low,\n                      ymax = high,\n                      color = metric),\n                  position = position_dodge(width=5)) +\n    scale_y_reverse(limits = c(600,0)) +\n    scale_x_date(date_labels = '%Y-%m',\n                 date_breaks = '1 month') +\n    labs(y = 'Depth [m]', col = \"\")+\n    theme_pubr()+\n    theme(axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1))\n  \n  plot_list[[i]]$full <- ggplot(wmd_df[year(wmd_df$date) >= 2020 &\n                                        wmd_df$cluster == clust,]) +\n    geom_point(aes(x = date,\n                   y = mid,\n                   color = metric),\n               position = position_dodge(width = 5)) +\n    geom_errorbar(aes(x = date,\n                      ymin = low,\n                      ymax = high,\n                      color = metric),\n                  position = position_dodge(width=5)) +\n    scale_y_reverse(limits = c(600,0)) +\n    scale_x_date(date_labels = '%Y-%m',\n                 date_breaks = '1 month') +\n    labs(y = 'Depth [m]', col = \"\", x =\"\")+\n    theme_pubr()+\n    theme(axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1))\n}\n\nggarrange(plot_list$c1$early + \n            theme(axis.title.x = element_blank(),\n                  axis.text.x = element_blank()), plot_list$c1$full + \n            theme(axis.title.y = element_blank(),\n                  axis.text.y = element_blank(),\n                  axis.text.x = element_blank(),\n                  axis.line.y = element_blank(),\n                  axis.ticks.y = element_blank(),\n                  axis.title.x = element_blank()),\n          plot_list$c2$early + \n            theme(axis.title.x = element_blank(),\n                  axis.text.x = element_blank(),), plot_list$c2$full + \n            theme(axis.title.y = element_blank(),\n                  axis.text.y = element_blank(),\n                  axis.text.x = element_blank(),\n                  axis.line.y = element_blank(),\n                  axis.ticks.y = element_blank(),\n                  axis.title.x = element_blank()),\n          plot_list$c3$early + \n            theme(axis.title.x = element_blank(),\n                  axis.text.x = element_blank(),), plot_list$c3$full + \n            theme(axis.title.y = element_blank(),\n                  axis.text.y = element_blank(),\n                  axis.text.x = element_blank(),\n                  axis.line.y = element_blank(),\n                  axis.ticks.y = element_blank(),\n                  axis.title.x = element_blank()),\n          plot_list$c4$early + \n            theme(axis.title.x = element_blank()), plot_list$c4$full + \n            theme(axis.title.y = element_blank(),\n                  axis.text.y = element_blank(),\n                  axis.line.y = element_blank(),\n                  axis.ticks.y = element_blank(),\n                  axis.title.x = element_blank()),\n          nrow = 4, ncol = 2,\n          common.legend = T,\n          widths = c(0.15, 0.85))"
  },
  {
    "objectID": "supp_04_wmd-by-season.html",
    "href": "supp_04_wmd-by-season.html",
    "title": "Weighted Mean Depth Across cruises",
    "section": "",
    "text": "Code\n#| column: screen-inset\n\nrm(list = ls())\nlibrary(EcotaxaTools)\nlibrary(ggplot2)\nlibrary(ggpubr)\nlibrary(lubridate)\nsource('../R/tools.R')\n\n# |- load in data ---------------------------------------------\nwmd_data <- readRDS('../data/04_wmd-by-cruise-seasonal.rds')\n\n\n# |- format wmd CIs for each cruise --------------------------\n\n# honestly, at this point I've created a ridiculous data structure\n# the list is too deep - it is a messy tree\n# there has to be a better way but this is going to just be an ugly solution\n# I have re-sampled distributions in a tree-like list. I then need to get the quantiles\n# and force it all into a top-level dataframe\n\nwmd_df <- wmd_df_construct(wmd_data, 'season')\n\nwmd_df <- wmd_df[-which(wmd_df$metric == 'dn_diff'),]\n\n###\n# Plotting ################\n###\n\n# setting up a plotting shell\nplot_list <- vector('list',length(unique(wmd_df$cluster)))\nnames(plot_list) <- unique(wmd_df$cluster)\n\nfor(i in 1:length(plot_list)) {\n  \n  clust <- names(plot_list)[i]\n  \n  plot_list[[i]]<- ggplot(wmd_df[wmd_df$cluster == clust,]) +\n    geom_point(aes(x = season,\n                   y = mid,\n                   color = metric),\n               position = position_dodge(width = .5),\n               size = 2) +\n    geom_errorbar(aes(x = season,\n                      ymin = low,\n                      ymax = high,\n                      color = metric),\n                  position = position_dodge(width=.5),\n                  size = 1,\n                  width = 0.5) +\n    scale_y_reverse(limits = c(600,0)) +\n    labs(y = 'Depth [m]', col = \"\", x = \"\")+\n    theme_pubr()+\n    theme(axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1))\n\n}\n\nggarrange(plot_list$c1 + \n            theme(axis.text.x = element_blank()),\n          plot_list$c2 + \n            theme(axis.text.x = element_blank()),\n          plot_list$c3 + \n            theme(axis.text.x = element_blank()),\n          plot_list$c4,\n          ncol =1, heights = c(.8,.8,.8,1),\n          common.legend = T)"
  },
  {
    "objectID": "main_02_PC-Clusters.html#morphogroup-definition-separation",
    "href": "main_02_PC-Clusters.html#morphogroup-definition-separation",
    "title": "Morphogroup Definition",
    "section": "Morphogroup definition separation",
    "text": "Morphogroup definition separation\nThe morphogroups defined by clustering in the PC-morphology space do not lend themselves to clear groupings. However, by inspecting the groups in the context of the morphospace, it can determined the characteristics best used to describe each group. Visually, it was determined that Cluster 1 can best be described by larger and more transparent copepods. Cluster 2 follows large values of PC1 and low values of PC2, which can be interpreted as containing both large-sized and darker copepods. Cluster 3 was best described by low values of PC1, interpreted as correlating to smaller-sized individuals. Finally, cluster 4 contains individuals with moderate PC1 scores and low PC2 scores, indicating darker, medium-to-small sized copepods.\nTo assure that these clusters were not trivial, each morphogroupâs scores on PC1 and PC2 were compared with pairwise Dunn tests. It was revealed that all groups were significantly different from one another along PC1 (p < 0.001 following Bonferroni correction for all groups, Supplemental 2). On PC2, cluster 2 and cluster 4 were not significantly different (p = 1), while all other groups were significantly different from one another (p < 0.001).\n\n\nCode\nFSA::dunnTest(PC1 ~ as.factor(cluster),\n              data = cluster_res,\n              method = 'bonferroni')$res |> \n  datatable(caption = 'PC1 Dunn multiple comprison test with bonferroni correction')\n\n\n\n\n\n\n\nCode\npc1_dist <- ggplot(cluster_res) +\n  geom_boxplot(aes(x = as.factor(cluster),\n                   y = PC1,\n                   fill = as.factor(cluster))) +\n  scale_fill_manual(values = gg_cbb_col(4))+\n  labs(x = \"Morphogroup\", y = 'PC1 - Size: Small-to-Large') + \n  theme_pubr() +\n  theme(legend.position = 'none')\n\n\nFSA::dunnTest(PC2 ~ as.factor(cluster),\n              data = cluster_res,\n              method = 'bonferroni')$res |> \n  datatable(caption = 'PC2 Dunn multiple comprison test with bonferroni correction')\n\n\n\n\n\n\n\nCode\npc2_dist <- ggplot(cluster_res) +\n  geom_boxplot(aes(x = as.factor(cluster),\n                   y = PC2,\n                   fill = as.factor(cluster))) +\n  scale_fill_manual(values = gg_cbb_col(4))+\n  labs(x = \"Morphogroup\", y = 'PC2 - Trans: dark-to-light') + \n  theme_pubr()+\n  theme(legend.position = 'none')\n\nggarrange(pc1_dist, pc2_dist, nrow=1)\n\n\n\n\n\nAdditionally, to exemplify morphogroup differences along original parameters, we plotted the distribution of individual metrics for key morphological parameters representing size and transparency. This clearly shows that morphogroups 1 & 2 are larger while 3 & 4 are smaller. Additionally morphogroups 2 & 4 are darker while 1 & 3 are smaller. Thus, the hypothesis that size and color will influence DVM signal would predict morphogroup 2 to have the largest DVM signal and morphogroup 3 to have the smallest DVM signal.\n\n\nCode\nuvp_data <- readRDS('../data/01_uvp-trim-final.rds') |> \n  trim_to_cope()\n\n####\n# Assign Clusters to individuals ########\n####\n\nfor(i in 1:length(uvp_data$zoo_files)) {\n  idx <- which(cluster_res$orig_id %in% uvp_data$zoo_files[[i]]$orig_id)\n  uvp_data$zoo_files[[i]]$cluster <- cluster_res$cluster[idx]\n}\n\nall_copes <- uvp_data$zoo_files |> \n  list_to_tib('profileid')\n\n# convert to mm\nall_copes$feret <- all_copes$feret * unique(uvp_data$meta$acq_pixel)\n\nferet_plot <- ggplot(all_copes) + \n  geom_boxplot(aes(x = as.factor(cluster),\n                   y = feret,\n                   fill = as.factor(cluster))) +  scale_fill_manual(values = gg_cbb_col(4))+\n  labs(x = \"Morphogroup\", y = 'Feret Diam [mm]') + \n  theme_pubr()+\n  theme(legend.position = 'none')\n\nmeanGrey_plot <- ggplot(all_copes) + \n  geom_boxplot(aes(x = as.factor(cluster),\n                   y = mean,\n                   fill = as.factor(cluster))) +  scale_fill_manual(values = gg_cbb_col(4))+\n  labs(x = \"Morphogroup\", y = 'Mean Grey Value') + \n  theme_pubr()+\n  theme(legend.position = 'none')\n\nggarrange(feret_plot, meanGrey_plot, rnow = 1)"
  },
  {
    "objectID": "supp_02_pc-extended-info.html#identifying-optimal-number-of-clusters-in-k-means-cluster",
    "href": "supp_02_pc-extended-info.html#identifying-optimal-number-of-clusters-in-k-means-cluster",
    "title": "Additional PCA Information",
    "section": "Identifying optimal number of clusters in k-means cluster",
    "text": "Identifying optimal number of clusters in k-means cluster\n4 clusters were chosen as the optimal number of clusters\n\n\nCode\n# get just the pc's we want, size and transparency\nmain_pcs <- pca_results$ind$coord[,c(1,2)]\n\n# |- Identifying the optimal clusters ----\n\ncluster_ss <- function(k, x) {\n  w <- kmeans(x, centers = k, iter.max= 100, nstart = 1000)\n  return(1 - (w$tot.withinss/w$totss))\n}\n\ncluster_curve <- c(1:10) |>  \n  sapply(cluster_ss, main_pcs) |> \n  suppressWarnings()\nplot(cluster_curve~c(1:10), type = 'b', xlab = 'Number of Clusters',ylab = 'Within SS / Total SS')\n\n\n\n\n\nCode\nprint('Explanitory power added for each new center added:')\n\n\n[1] \"Explanitory power added for each new center added:\"\n\n\nCode\nrbind(numCluster = seq(2,10,1), AddedExplain= diff(cluster_curve))\n\n\n                  [,1]      [,2]      [,3]       [,4]       [,5]       [,6]\nnumCluster   2.0000000 3.0000000 4.0000000 5.00000000 6.00000000 7.00000000\nAddedExplain 0.3432048 0.2003371 0.1025766 0.06321141 0.04564529 0.03212488\n                   [,7]       [,8]        [,9]\nnumCluster   8.00000000 9.00000000 10.00000000\nAddedExplain 0.02464068 0.02295813  0.01461537\n\n\nCode\n# Four clusters seems to be the most elbowish\n# Explains ~65% of variability, adding k is >10% variability"
  }
]